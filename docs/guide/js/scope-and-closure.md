# 作用域与闭包

## 一、作用域与作用域链

### 1. 作用域

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

::: tip 注意
在 ES6 规范中，作用域概念变为词法环境概念。
:::

词法环境：
在 [ES6 规范](https://tc39.es/ecma262/#sec-lexical-environments)中，词法环境（LexicalEnvironment）是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项（Environment Record）和可能为空的外部词法环境引用（outer Lexical Environment）构成。

```
[[LexicalEnvironment]] = {
  [[Environment Record]],
  [[Outer Lexical Environment]]
}
```

词法环境分了三类：

- 全局环境（global environment）： 全局环境是一个没有外部环境的词法环境。全局环境外部环境引用为 `null`。全局环境的 EnvironmentRecord（环境记录）可以绑定变量，并关联对应的全局对象。
- 模块环境（module environment）： 模块环境也是一个词法环境，它包含模块顶级声明的绑定。它还包含模块显式导入的绑定。模块环境的外部环境是全局环境。
- 函数环境（function environment）： 函数环境也是一个词法环境，对应于 ECMAScript 函数对象的调用。函数环境可以建立新的此绑定。函数环境还支持 super 调用所需的状态。

环境记录项（Environment Record）分为 5 类：

- 声明式环境记录项（Declarative Environment Records）： 用于绑定作用域内定义的一系列标识符。例如变量，常量，`let`，`class`，`module`，`import` 以及函数声明等。
- 对象式环境记录项（Object Environment Records）： 每一个对象式环境记录项都有一个关联的对象，这个对象被称作绑定对象 。对象式环境记录项直接将一系列标识符与其绑定对象的属性名称建立一一对应关系。
- 函数环境记录项（Function Environment Records）
- 全局环境记录项（Global Environment Records）
- 模块环境记录项（Module Environment Records）

### 2. 作用域链

- 全局环境的外部词法环境引用为 `null`。
- 一个词法环境可以作为多个词法环境的外部环境。例如全局声明了多个函数，则这些函数词法环境的外部词法环境引用都指向全局环境。

**当代码试图访问一个变量时 —— 它首先会在内部词法环境中进行搜索，然后是外部环境，然后是更外部的环境，直到（词法环境）链的末尾。**

外部词法环境的引用将一个词法环境和其外部词法环境链接起来，外部词法环境又拥有对其自身的外部词法环境的引用。这样就形成一个链式结构，这里我们称其为环境链（即 ES6 之前的作用域链），全局环境是这条链的顶端。

## 二、执行上下文与执行上下文栈

### 1. 执行上下文

执行上下文也叫执行环境（Execution Context）, 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。

对于每个执行上下文，都含有以下几个部分：

- 词法环境组件: 指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。
- 变量环境组件: 指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过 VariableStatement 和 FunctionDeclaration 创建的绑定。
- this 绑定： 指定该执行环境内的 ECMA 脚本代码中 this 关键字所关联的值。

### 2. 执行上下文的类型

- 全局执行上下文：这是默认的，最基础的上下文。它做了两件事，

  - 创建一个全局对象，在浏览器中这个全局对象就是 window 对象；
  - 将 this 指针指向这个全局对象。

- 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。
- eval 函数执行上下文：运行在 eval 函数中的代码也获得自己的执行上下文。

### 3. 执行上下文的生命周期

执行上下文的生命周期包含三个阶段：创建阶段->执行阶段->回收阶段

1. 创建阶段：

当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

- 确定 this 的值
- LexicalEnvironment （词法环境）组件被创建。
- VariableEnvironment （变量环境）组件被创建。

```
ExecutionContext = {
  ThisBinding = <this value>,     // 确定this
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
```

2. 执行阶段

执行变量赋值、代码执行。

3. 回收阶段

执行上下文出栈等待虚拟机回收。

### 4. 执行上下文栈

执行上下文栈其实是一个先进后出的栈结构，被用来存储代码运行时创建的所有执行上下文。

当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。

## 三、this 的原理

1. `this`：当前执行代码的环境对象。

在绝大多数情况下，函数的调用方式决定了 `this` 的值。

`this` 不能在执行期间被赋值，并且在每次函数被调用时`this`的值也可能会不同。

ES5 引入了 `bind` 方法来设置函数的 `this` 值，而不用考虑函数如何被调用的，ES2015 引入了支持 `this` 词法解析的箭头函数（它在闭合的执行环境内设置 `this` 的值）。

2. 场景

a. 全局环境：无论是否是在严格模式下，在全局执行环境中，`this` 都指向全局对象。

b. 函数（运行时）环境：在函数内部，`this` 的取值取决于函数被调用的方式。

- 简单调用：在严格模式下为 `undefined`，非严格模式下指向全局对象。

```js
function foo() {
  console.log(this);
}
foo(); // window or undefined
```

- `call/apply`：指向绑定到调用中的特定对象。
- `bind`方法：`bind` 方法会创建一个与原函数具有相同函数体和作用域的函数。`this` 指向绑定的对象。
- 箭头函数：没有 `this`，如果访问 `this`，则从外部环境获取。
- 作为对象的方法：`this` 指向调用该函数的对象。
- 作为构造函数：`this` 指向被构造的实例对象。
- 作为 DOM 事件处理函数：`this` 指向触发事件的 DOM 元素。

## 闭包与实际的运用场景

> 函数保存其外部的变量并且能够访问它们称之为闭包。

> 在某些语言中，是没有闭包的，或是以一种特别方式来实现。
> 但正如上面所说的，在 JavaScript 中函数都是天生的闭包（只有一个例外，请参考 "newFunction" 语法）。
> 也就是说，他们会通过隐藏的 `[[Environment]]` 属性记住创建它们的位置，所以它们都可以访问外部变量。

### 1. 闭包

在我看来，函数与其外部词法环境的引用就构成**闭包**。

闭包的核心是**词法环境**，词法环境由环境记录项和可能为空的外部词法环境引用构成。

在执行环境创建的时候，就生成了类似环境链的数据结构，词法环境是彼此独立的，当前执行环境访问变量时，首先会先从当前词法环境里查找，没找到继续沿着外部词法作用域查找，直到词法环境链的末尾。

### 2. 实际运用

- 模拟私有方法
- 存储变量
- 循环中的闭包
