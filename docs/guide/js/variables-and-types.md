

## js 变量在内存中的存储形式

在 js 中，变量分为**基本类型**和**引用类型**。基本类型是保存在栈内存中的简单数据段，它们的值都有**固定的大小**，保存在**栈空间**，通过**按值访问**。引用类型是保存在堆内存中的对象，**值大小不固定**，栈内存中存放的该对象的访问地址指向堆内存中的对象，js 中不允许直接访问堆内存中的为止。因此操作对象时，实际操作对象的引用，

## js 的数据类型

js 有 7 种数据类型：

- `number` 类型：整数或浮点数。依据 IEEE 754 标准，使用的是 64 位双精度浮点数存储。
- `string` 字符串：由一组 UTF16 编码组成，范围在 0~65536(U+0000 ~U+FFFF)之间。
- `boolean` 布尔值：二元判断，只有`true`和`false`
- `null`: 无、未知
- `undefined`: 表示未定义。不是保留字，内层作用域可以被覆写。
- `symbol`: 用于唯一的标识符。
- `object` 对象：一般是键值对的形式。

::: tip 提示
`function` 是一种数据类型吗？
根据 spec 规范，它不是。虽然 `typeof function() {}; // function`，但是`typeof`是一个运算符，其返回值不能作为 js 类型系统的依据。`function`比较特殊，它同样具有`object`的特性。
:::

## 基本类型的拆箱与装箱操作

### **装箱**

装箱，是指将基本类型转换为对应的引用类型的操作。分为**显式装箱**和**隐式装箱**。

1. 隐式装箱

```js
var s1 = 'alin';
var s2 = s1.substring(2);
```

上述代码的执行步骤：

- 创建 `String`类型的一个实例
- 在实例中调用该方法
- 销毁该实例

2. 显式装箱

通过**基本包装类型对象**对基本类型进行显示装箱。

```js
var str = new String('alin');
```

显式装箱可以对 `new` 出来的对象进行属性和方法的添加。

因为通过`new`操作符创建的引用类型的实例，在执行流离开当前作用域之间会一直保留在内存中。

### **拆箱**

拆箱，是指把引用类型转换为基本类型。通过引用类型的 `valueOf()` 和 `toString`方法实现。

在 js 标准中，规定了 `ToPrimitive`方法，它是对象类型到基本类型转换的实现者。

对象到 String 和 Number 的转换遵循“先拆箱后转换”的规则。

## null 与 undefined 的区别

## 隐式转换

## 精度缺失

## Javascript 的内存管理与内存泄漏

### 内存

内存从物理意义上是指由一系列晶体管构成的可以存储数据的回路，从逻辑的角度我们可以将内存看作是一个巨大的可读写的比特数组。

它存储着我们编写的代码以及我们在代码中定义的各类变量。对于很多静态类型编程语言来说，在代码进入编译阶段时编译器会根据变量声明时指定的类型提前申请分配给该变量的内存（比如，整型变量对应的是 4 个字节，浮点数对应 8 个字节）。

内存区域分为**栈空间**和**堆空间**。

- 栈空间：在编译阶段就能确定内存大小的变量，FILO
- 堆空间：变量占用内存大小是在运行时决定的，动态分配的。

### 内存的生命周期

分配内存 -> 使用内存 -> 释放内存

### 内存回收

1. 引用计数
2. 标记清除算法

标记清除判断某个对象是否可以被回收的标志是该对象不能再被访问到。其执行过程总共分为三步：

- a. 确定根对象：在 javascript 中根对象主要是指全局对象，比如浏览器环境中的 window，node.js 中的 global。
- b. 从根对象开始遍历子属性，并将这些属性变量标记为活跃类型，通过根对象- 不能访问到的就标记为可回收类型。
- c. 根据第二步标记出来的结果进行内存回收

### 内存泄漏

内存泄漏是指未能被垃圾回收机制回收，导致这块内存区域被白白浪费的。

常见的内存泄漏：

1. 全局变量

```js
function foo() {
  bar = 'global variable';
}
```

2. 闭包

内部函数可以访问到其外部作用域中的变量。

3. `DOM`引用
