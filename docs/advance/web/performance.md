# 前端性能优化

## 网络相关

### 使用 HTTP/2.0

因为浏览器会有并发请求限制，在 HTTP/1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

在 HTTP/2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

### 减少资源请求量

- 小图片资源 base64 编码内联。
- 将多个图标文件整合到一张图片中（雪碧图）
- JS 文件合并

### DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<link rel="dns-prefetch" href="//xxx.com" />
```

### CDN

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

## 资源

通过了一系列的网络请求过程，资源到了下载的过程。

资源下载的耗时 = 资源大小 / 用户网速。

用户网速我们无法控制，那么资源的瓶颈其实很显而易见：资源大小。减少资源文件大小，就能降低资源下载耗时。

### 使用合适的缓存策略

缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。

通常浏览器缓存策略分为两种：**强缓存**和**协商缓存**。

#### 强缓存

实现强缓存可以通过两种响应头部实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，HTTP 状态码为 `200（from cache）`

1. Expires

`Expires` 是 HTTP/1.0 的产物。`Expires` 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面例子,

```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，过期后就得向服务器再次发起请求。由于 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

2. Cache-Control

在 HTTP/1.1 中，采用了新的首部，`Cache-Control`，它使用过期时长`max-age`来控制缓存，并且其优先级高于 `Expires` 。比如下面的例子，表示资源会在 30 秒后过期，需要再次请求。

```js
Cache-control: max-age=30
```

`Cache-Control` 还有一些其他的属性：

- `public`: 客户端和代理服务器都可以缓存。
- `private`：这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
- `no-cache`：跳过当前的强缓存，发送 HTTP 请求，即直接进入协商缓存阶段。
- `no-store`：不适用任何形式的缓存。
- `s-maxage`: 针对代理服务器的缓存时间。

#### 协商缓存

强缓存失效后，浏览器就会发起请求来进行协商缓存。协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 `304（not modified）`。

1. `Last-Modified` 和 `If-Modified-Since`

`Last-Modified` 表示本地文件最后修改日期，服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 304，告诉浏览器直接用缓存。

缺点是`Last-Modified`不能准确的感知文件的变化。如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP/1.1 出现了 `ETag`。

2. `ETag` 和 `If-None-Match`

`ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。`ETag` 优先级比 `Last-Modified` 高。

浏览器接收到`ETag`的值，会在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到 `If-None-Match` 后，会跟服务器上该资源的 `ETag` 进行比对:

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 304，告诉浏览器直接用缓存。

#### 缓存存储位置

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

1. Service Worker

Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。

2. Memory Cache 和 Disk Cache

Memory Cache 指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

Disk Cache 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

3. Push Cache

推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

#### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

### 文件优化

#### 打包压缩

- 通过构建工具(Grunt/Gulp/webpack 等) 打包压缩，混淆加密；
- 使用生产环境构建依赖库，去除依赖库中无用的开发提示代码；
- 使用 ES6 模块来开启 tree shaking，移除没有使用的代码；
- 优化图片，对于小图可以使用 base64 的方式写入文件中，减少多余的请求；
- 按照路由拆分代码，实现按需加载；
- 给打包出来的文件名添加哈希，实现浏览器缓存文件；
- 服务器启用 gzip

#### 图片优化

- 适当压缩图片大小，尽量不使用原图。
- 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
- 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
- 照片使用 JPEG

## 优化渲染过程

### 减少重绘和回流

- 使用 `translate` 替代 `top`

```html
<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector('.test').style.top = '100px';
  }, 1000);
</script>
```

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- 把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来

- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量

```js
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop);
}
```

- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`

- CSS 选择符从右往左匹配查找，避免 DOM 深度过深

- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。

### 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

### 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### 懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

### 懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

### 避免 JS 文件阻塞渲染

当浏览器碰到 script 脚本的时候：

1. 常规脚本

```html
<script src="script.js"></script>
```

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. async

```html
<script async src="script.js"></script>
```

有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

3. defer

```html
<script defer src="script.js"></script>
```

有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

![perform-js脚本不同方式-2019-12-25.jpg](https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/perform-js脚本不同方式-2019-12-25.jpg?x-oss-process=style/alin)

蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。

### 使用 web worker

执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。
