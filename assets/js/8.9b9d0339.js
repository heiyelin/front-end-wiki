(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{276:function(t,r,v){"use strict";v.r(r);var _=v(2),a=Object(_.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"浏览器工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器工作原理"}},[t._v("#")]),t._v(" 浏览器工作原理")]),t._v(" "),v("h2",{attrs:{id:"浏览器进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程"}},[t._v("#")]),t._v(" 浏览器进程")]),t._v(" "),v("p",[t._v("最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。")]),t._v(" "),v("ul",[v("li",[t._v("浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")]),t._v(" "),v("li",[t._v("渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")]),t._v(" "),v("li",[t._v("GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")]),t._v(" "),v("li",[t._v("网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")]),t._v(" "),v("li",[t._v("插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")])]),t._v(" "),v("h2",{attrs:{id:"从输入-url-到页面加载完成的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从输入-url-到页面加载完成的过程"}},[t._v("#")]),t._v(" 从输入 URL 到页面加载完成的过程")]),t._v(" "),v("ul",[v("li",[t._v("首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来")]),t._v(" "),v("li",[t._v("接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了")]),t._v(" "),v("li",[t._v("TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据")]),t._v(" "),v("li",[t._v("数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件")]),t._v(" "),v("li",[t._v("首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错")]),t._v(" "),v("li",[t._v("浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件")]),t._v(" "),v("li",[t._v("文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。")]),t._v(" "),v("li",[t._v("初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件")]),t._v(" "),v("li",[t._v("CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西")]),t._v(" "),v("li",[t._v("在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了")])]),t._v(" "),v("h2",{attrs:{id:"渲染机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染机制"}},[t._v("#")]),t._v(" 渲染机制")])])}),[],!1,null,null,null);r.default=a.exports}}]);