<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DOM 编程 | Front-End-Wiki</title>
    <meta name="description" content="前端知识库">
    
    <meta property="article:modified_time" content="2019-12-25T15:50:08.000Z"><meta property="og:site_name" content="Front-End-Wiki"><meta property="og:title" content="DOM 编程"><meta property="og:type" content="website"><meta property="og:url" content="/advance/web/dom.html"><meta name="twitter:title" content="DOM 编程"><meta name="twitter:url" content="/advance/web/dom.html"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:label1" content="Written by">
    <link rel="preload" href="/assets/css/0.styles.9e24d197.css" as="style"><link rel="preload" href="/assets/js/app.0d36fc07.js" as="script"><link rel="preload" href="/assets/js/2.b6aa8f81.js" as="script"><link rel="preload" href="/assets/js/10.8bfd4ea1.js" as="script"><link rel="prefetch" href="/assets/js/11.fe52658a.js"><link rel="prefetch" href="/assets/js/12.e0e30b8d.js"><link rel="prefetch" href="/assets/js/13.1387d8d2.js"><link rel="prefetch" href="/assets/js/14.8288dbb9.js"><link rel="prefetch" href="/assets/js/15.5d7d6b17.js"><link rel="prefetch" href="/assets/js/16.eecd39ae.js"><link rel="prefetch" href="/assets/js/17.a2d9791b.js"><link rel="prefetch" href="/assets/js/18.3f3747e5.js"><link rel="prefetch" href="/assets/js/19.1cfd61e5.js"><link rel="prefetch" href="/assets/js/20.20c1d3b4.js"><link rel="prefetch" href="/assets/js/21.3b46cf8b.js"><link rel="prefetch" href="/assets/js/22.49b56ccd.js"><link rel="prefetch" href="/assets/js/23.04f55964.js"><link rel="prefetch" href="/assets/js/24.d4de5079.js"><link rel="prefetch" href="/assets/js/25.aba0c982.js"><link rel="prefetch" href="/assets/js/26.731d50fe.js"><link rel="prefetch" href="/assets/js/27.292b230a.js"><link rel="prefetch" href="/assets/js/28.ce5173b2.js"><link rel="prefetch" href="/assets/js/29.863219a8.js"><link rel="prefetch" href="/assets/js/3.6a70c1fb.js"><link rel="prefetch" href="/assets/js/30.398b963b.js"><link rel="prefetch" href="/assets/js/31.8c7b3aa2.js"><link rel="prefetch" href="/assets/js/32.b3465a7f.js"><link rel="prefetch" href="/assets/js/33.51b95476.js"><link rel="prefetch" href="/assets/js/34.040e3223.js"><link rel="prefetch" href="/assets/js/35.a62cada5.js"><link rel="prefetch" href="/assets/js/36.4f915af0.js"><link rel="prefetch" href="/assets/js/37.ec23df85.js"><link rel="prefetch" href="/assets/js/38.7605bc0e.js"><link rel="prefetch" href="/assets/js/39.b50c2b8b.js"><link rel="prefetch" href="/assets/js/4.f998eb39.js"><link rel="prefetch" href="/assets/js/40.2e9d8fee.js"><link rel="prefetch" href="/assets/js/41.fddf0c31.js"><link rel="prefetch" href="/assets/js/42.ddf5dc0a.js"><link rel="prefetch" href="/assets/js/43.2163f6ed.js"><link rel="prefetch" href="/assets/js/44.97cd1965.js"><link rel="prefetch" href="/assets/js/45.50edd4c2.js"><link rel="prefetch" href="/assets/js/46.dcbd0d34.js"><link rel="prefetch" href="/assets/js/47.ab312a1d.js"><link rel="prefetch" href="/assets/js/48.e29f594f.js"><link rel="prefetch" href="/assets/js/5.bd41f6e8.js"><link rel="prefetch" href="/assets/js/6.cfeabc90.js"><link rel="prefetch" href="/assets/js/7.df74b918.js"><link rel="prefetch" href="/assets/js/8.9b9d0339.js"><link rel="prefetch" href="/assets/js/9.d13b94b4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9e24d197.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Front-End-Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/guide/" class="nav-link">基础</a></div><div class="nav-item"><a href="/advance/" class="nav-link router-link-active">进阶</a></div><div class="nav-item"><a href="/dev/" class="nav-link">全栈</a></div><div class="nav-item"><a href="/refer/" class="nav-link">扩展</a></div> <a href="https://github.com/heiyelin/front-end-wiki" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/guide/" class="nav-link">基础</a></div><div class="nav-item"><a href="/advance/" class="nav-link router-link-active">进阶</a></div><div class="nav-item"><a href="/dev/" class="nav-link">全栈</a></div><div class="nav-item"><a href="/refer/" class="nav-link">扩展</a></div> <a href="https://github.com/heiyelin/front-end-wiki" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>深入</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/advance/web/dom.html" class="active sidebar-link">DOM 编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/advance/web/dom.html#浏览器环境" class="sidebar-link">浏览器环境</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#dom-树" class="sidebar-link">DOM 树</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#dom-节点类与节点属性" class="sidebar-link">DOM 节点类与节点属性</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#dom-操作" class="sidebar-link">DOM 操作</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#样式操作" class="sidebar-link">样式操作</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#元素的尺寸与滚动" class="sidebar-link">元素的尺寸与滚动</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#window-尺寸与滚动" class="sidebar-link">window 尺寸与滚动</a></li><li class="sidebar-sub-header"><a href="/advance/web/dom.html#坐标" class="sidebar-link">坐标</a></li></ul></li><li><a href="/advance/web/browser.html" class="sidebar-link">前端与浏览器</a></li><li><a href="/advance/web/browser-working-principle.html" class="sidebar-link">浏览器工作原理</a></li><li><a href="/advance/web/performance.html" class="sidebar-link">前端性能优化</a></li><li><a href="/advance/web/js-run-mechanism.html" class="sidebar-link">执行机制</a></li><li><a href="/advance/web/react-concept.html" class="sidebar-link">React 一些重要的概念</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/advance/nodejs/" class="sidebar-link">Node.js</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="dom-编程"><a href="#dom-编程" class="header-anchor">#</a> DOM 编程</h1> <h2 id="浏览器环境"><a href="#浏览器环境" class="header-anchor">#</a> 浏览器环境</h2> <p>JavaScript 语言最初是为 Web 浏览器创建的。Web 浏览器作为宿主环境，提供了很多 API 来满足查看网页、图片、音视频等需求。下面是浏览器在 Javascript 运行时的鸟瞰图。</p> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-web-2019-12-25.png?x-oss-process=style/alin" alt="dom-web-2019-12-25.png"></p> <p>浏览器环境由三部分组成：</p> <ol><li>DOM(文档对象模型)标准</li></ol> <p>描述文档的结构、操作和事件，参见 https://dom.spec.whatwg.org。</p> <ol start="2"><li>CSSOM 标准</li></ol> <p>介绍样式表和样式规则，对它们的操作及其对文档的绑定，参见 https://www.w3.org/TR/cssom-1/.</p> <ol start="3"><li>HTML 标准</li></ol> <p>介绍 HTML 语言（例如标签）以及 BOM（浏览器对象模型）—— 各种浏览器函数：<code>setTimeout</code>、<code>alert</code>、<code>location</code> 等等，请参阅 https://html.spec.whatwg.org。它采用了 DOM 规范并为其扩展了许多属性和方法。</p> <h2 id="dom-树"><a href="#dom-树" class="header-anchor">#</a> DOM 树</h2> <p>浏览器会将 HTML/XML 解析为 DOM 树。</p> <h3 id="节点类型"><a href="#节点类型" class="header-anchor">#</a> 节点类型</h3> <p>有 12 种节点类型。实际上，通常用到的有以下几个：</p> <ul><li><strong><code>document</code></strong>：DOM 树的根节点</li> <li><strong>元素节点</strong>：HTML 标签，“树枝”</li> <li><strong>文本节点</strong>：纯文本，“树叶”</li> <li><strong>注释节点</strong>：注释</li></ul> <h3 id="访问-dom"><a href="#访问-dom" class="header-anchor">#</a> 访问 DOM</h3> <p>DOM 让我们可以对元素和它们其中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象，把这个对象赋予一个变量，然后我们才能修改这个对象。</p> <p>对 DOM 的所有操作都是从 <code>document</code> 对象开始的。从这个对象我们可以到达任何节点。下图描述的是 DOM 节点之间的联系。</p> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E9%81%8D%E5%8E%86dom%E6%A0%91-2019-12-25.png?x-oss-process=style/alin" alt="dom-遍历dom树-2019-12-25.png"></p> <h4 id="_1-根节点"><a href="#_1-根节点" class="header-anchor">#</a> 1. 根节点</h4> <ul><li><code>document</code>：是整个 DOM 树的根节点。</li> <li><code>document.documentElement</code>：对应<code>&lt;html&gt;</code>标签的节点。</li> <li><code>document.body</code>：对应<code>&lt;body&gt;</code>标签的节点。</li> <li><code>document.head</code>：对应<code>&lt;head&gt;</code>标签的节点。</li></ul> <h4 id="_2-父节点"><a href="#_2-父节点" class="header-anchor">#</a> 2. 父节点</h4> <p>父节点可以通过 <code>parentNode</code> 访问。</p> <h4 id="_3-子节点"><a href="#_3-子节点" class="header-anchor">#</a> 3. 子节点</h4> <ul><li><code>childNodes</code>: 集合提供了对所有子节点包括其中文本节点的访问。</li> <li><code>firstChild</code>: 访问第一个子元素。</li> <li><code>lastChild</code>: 访问最后一个子元素。</li></ul> <h4 id="_4-兄弟节点"><a href="#_4-兄弟节点" class="header-anchor">#</a> 4. 兄弟节点</h4> <p>兄弟节点可以通过 <code>nextSibling</code> 和 <code>previousSibling</code> 访问。</p> <h4 id="_5-元素节点"><a href="#_5-元素节点" class="header-anchor">#</a> 5. 元素节点</h4> <p><code>childNodes</code> 不仅存在元素节点，还有文本节点，甚至是注释节点。在日常的使用中，我们更多的是只需要访问元素节点，排除掉其他干扰节点。</p> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9-2019-12-25.png?x-oss-process=style/alin" alt="dom-访问元素节点-2019-12-25.png"></p> <ul><li><code>parentElement</code>：父元素节点</li> <li><code>children</code>：只获取类型为元素节点的子节点。</li> <li><code>firstElementChild, lasElementChild</code> ： 第一个和最后一个子元素节点。</li> <li><code>previousElementSibling, nextElementSibling</code>：前一个和后一个兄弟元素节点。</li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><code>document.documentElement</code> 没有 <code>parentElement</code> 。因为 <code>document.documentElement</code> 的父节点是 <code>document</code> ，但 <code>document</code> 不是一个元素节点。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>parentNode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// document</span>
<span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>parentElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></div> <h4 id="_6-访问-dom-节点的方法"><a href="#_6-访问-dom-节点的方法" class="header-anchor">#</a> 6. 访问 DOM 节点的方法</h4> <ul><li><p><code>document.getElementById</code></p> <p>id 必须唯一，文档中给定的 id 只能有唯一一个元素。
如果有多个元素具有同名 id，那么对应方法的行为将不可预测。浏览器将随机返回其他的一个。因此未来保证 id 的唯一性，请严格遵守规则。</p></li> <li><p><code>getElementsBy*</code></p> <ul><li><code>getElementByTagsName(tag)</code>——用给点的标签来查找元素。</li> <li><code>getElementsByClassName(className)</code>——返回具有给点 CSS 类的元素。</li> <li><code>getElementsByName(name)</code>——返回具有给点 <code>name</code> 属性的元素。很少使用。</li></ul></li> <li><p><code>querySelectorAll</code> 和 <code>querySelector</code></p> <p><code>elem.querySelectorAll(css)</code>——返回与给定 CSS 选择器匹配的 <code>elem</code> 中的所有元素。
<code>elem.querySelector(css)</code>——返回给定 CSS 选择器的第一个元素。</p></li> <li><p><code>matches</code> <code>elem.matchs(css)</code>——检查 <code>elem</code> 是否匹配给点的 CSS 选择器。</p></li> <li><p><code>closet</code> <code>elem.closet(css)</code> ——查找与 CSS 选择器匹配的最接近的祖先。</p></li></ul> <h2 id="dom-节点类与节点属性"><a href="#dom-节点类与节点属性" class="header-anchor">#</a> DOM 节点类与节点属性</h2> <h3 id="dom-节点类"><a href="#dom-节点类" class="header-anchor">#</a> DOM 节点类</h3> <p>DOM 节点因为它们的类而具有不同的属性。例如，标记 <code>&lt;a&gt;</code> 相对应的元素节点具有链接相关的属性，标记 <code>&lt;input&gt;</code> 对应元素节点具有的输入相关的属性等。文本节点不同于元素节点，但是它们之间也存在共有的属性和方法，因为所有的 DOM 节点都形成一个单一层次的结构。</p> <p>每个 DOM 节点都有与之对应的内置类。层次的根节点是 <a href="https://dom.spec.whatwg.org/#eventtarget" target="_blank" rel="noopener noreferrer">EventTarget<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，<a href="http://dom.spec.whatwg.org/#interface-node" target="_blank" rel="noopener noreferrer">Node<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 继承自它，其他 DOM 节点也继承自它。</p> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E8%8A%82%E7%82%B9%E7%B1%BB-2019-12-25.png?x-oss-process=style/alin" alt="dom-节点类-2019-12-25.png"></p> <p>类如下所示：</p> <ul><li><a href="https://dom.spec.whatwg.org/#eventtarget" target="_blank" rel="noopener noreferrer">EventTarget<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— 是根的“抽象”类。该类的对象从未被创建。它作为一个基础，为了让所有 DOM 节点都支持所谓的“事件”，我们会在之后对它进行学习。</li> <li><a href="http://dom.spec.whatwg.org/#interface-node" target="_blank" rel="noopener noreferrer">Node<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— 也是一个“抽象”类，充当 DOM 节点的基础。它提供了树的核心功能：<code>parentNode</code>、<code>nextSibling</code>、<code>childNodes</code> 等（它们都是 getter）。<code>Node</code> 类的对象从未被创建。但是一些具体的节点类却继承自它，例如：<code>Text</code> 表示文本节点，<code>Element</code> 用于元素节点，以及更多外来的类（如注释节点 <code>Comment</code>）。</li> <li><a href="http://dom.spec.whatwg.org/#interface-element" target="_blank" rel="noopener noreferrer">Element<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— 是 DOM 元素的基类。它提供了元素级的导航，比如 <code>nextElementSibling</code>、<code>children</code> 以及像 <code>getElementsByTagName</code>、<code>querySelector</code> 这样的搜索方法。浏览器中不仅有 HTML，还会有 XML 和 SVG 文档。<code>Element</code> 类充当以下更具体类的基类：<code>SVGElement</code>、<code>XMLElement</code> 和 <code>HTMLElement</code>。</li> <li><a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement" target="_blank" rel="noopener noreferrer">HTMLElement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>—— 最终会成为所有 HTML 元素的基类。由各种 HTML 元素继承：
<ul><li><a href="https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement" target="_blank" rel="noopener noreferrer">HTMLInputElement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— <code>&lt;input&gt;</code> 元素的类，</li> <li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement" target="_blank" rel="noopener noreferrer">HTMLBodyElement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— <code>&lt;body&gt;</code> 元素的类，</li> <li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement" target="_blank" rel="noopener noreferrer">HTMLAnchorElement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— <code>&lt;a&gt;</code> 元素的类，</li> <li>等等，每个标记都有可以为自己提供特定属性和方法的类。</li></ul></li></ul> <p>因此，给定节点的全部属性和方法都是继承的结果。</p> <p>例如，我们考虑一下 <code>&lt;input&gt;</code> 元素的 DOM 对象。它属于 <a href="https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement" target="_blank" rel="noopener noreferrer">HTMLInputElement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 类。它将属性和方法作为以下内容的叠加：</p> <ul><li><code>HTMLInputElement</code> —— 该类提供特定于输入的属性，而且可以继承…</li> <li><code>HTMLElement</code> —— 它提供了通用 HTML 元素方法（getter 和 setter），而且可以继承自其它属性。</li> <li><code>Element</code> —— 提供泛型元素方法，而且可以继承自其它属性。</li> <li><code>Node</code> —— 提供通用 DOM 节点属性，而且可以继承自其它属性。</li> <li><code>EventTarget</code> —— 为事件（包括事件本身）提供支持，</li> <li>最后，它继承了 <code>Object</code>，因为像 <code>hasOwnProperty</code> 的“纯对象”方法也是可用的。</li></ul> <h3 id="节点属性"><a href="#节点属性" class="header-anchor">#</a> 节点属性</h3> <ol><li><code>nodeType</code> 属性</li></ol> <ul><li>元素节点—— <code>nodeType = 1</code></li> <li>文本节点—— <code>nodeType = 3</code></li> <li><code>document</code>节点—— <code>nodeType = 9</code></li></ul> <ol start="2"><li><code>nodeName</code> 与 <code>tagName</code></li></ol> <ul><li><code>tagName</code>属性仅用于 <code>Element</code>节点。</li> <li><code>nodeName</code>属性用于所有 <code>Node</code>节点：
<ul><li>对于元素节点，与 <code>tagName</code>一致。</li> <li>对于其他节点，则是一个字符串的节点类型。如 <code>#document</code> ， <code>#comment</code></li></ul></li></ul> <ol start="3"><li><code>innerHTML</code>, <code>outerHTML</code>, <code>textContent</code></li></ol> <ul><li><code>innerHTML</code>赋值会完全重写。</li> <li><code>outerHTML</code>包含元素完整的 HTML。</li> <li><code>textContent</code>返回元素的文本信息，去掉所有的 <code>&lt;tags&gt;</code> 。所有字符都当做字面量处理。</li></ul> <ol start="4"><li><code>nodeValue</code> 与 <code>data</code>：文本节点内容</li></ol> <p>用于获取文本节点的属性。</p> <ol start="5"><li><code>hidden</code> 属性：指定 DOM 元素是否可见。</li> <li>更多属性</li></ol> <ul><li><code>value</code> ——获取 <code>HTMLInputElement</code>的值。</li> <li><code>href</code> ——获取 <code>&lt;a&gt;</code>的链接。</li></ul> <h2 id="dom-操作"><a href="#dom-操作" class="header-anchor">#</a> DOM 操作</h2> <p>常见操作：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">let</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;alert alert-success&quot;</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> &quot;
  <span class="token operator">&lt;</span>strong<span class="token operator">&gt;</span>Hi there<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>strong<span class="token operator">&gt;</span> You've read an important message<span class="token punctuation">.</span>&quot;<span class="token punctuation">;</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="旧的插值方法"><a href="#旧的插值方法" class="header-anchor">#</a> 旧的插值方法</h3> <ul><li><code>parentElem.appendChild(node)</code></li> <li><code>parentElem.insertBefore(node)</code></li> <li><code>parentElem.replaceChild(node)</code></li> <li><code>parentElem.removeChild(node)</code></li></ul> <p>缺点：不够灵活，删除节点或者插入节点需要操作父节点。</p> <h3 id="新的插值方法"><a href="#新的插值方法" class="header-anchor">#</a> 新的插值方法</h3> <ul><li><code>node.append(...nodes or strings)</code> —— 在 <code>node</code> 末尾插入节点或者字符串，</li> <li><code>node.prepend(...nodes or strings)</code> —— 在 <code>node</code> 开头插入节点或者字符串，</li> <li><code>node.before(...nodes or strings)</code> —— 在 <code>node</code> 前面插入节点或者字符串，</li> <li><code>node.after(...nodes or strings)</code> —— 在 <code>node</code> 后面插入节点或者字符串，</li> <li><code>node.replaceWith(...nodes or strings)</code> —— 将 <code>node</code> 替换为节点或者字符串。</li> <li><code>node.remove()</code> ——从当前位置移除 <code>node</code> 。</li></ul> <p>缺点：字符串以安全的方式插入到页面中，就像调用 <code>elem.textContent</code>  方法一样。</p> <h3 id="insertadjacenthtml"><a href="#insertadjacenthtml" class="header-anchor">#</a> insertAdjacentHTML</h3> <p><code>elem.insertAdjacentHTML(where, html)</code>  方法第一个参数是代码字符串，指定相对于 <code>elem</code> 的插入位置，必须是以下四个值之一：</p> <ul><li><code>&quot;beforebegin&quot;</code> —— 在 <code>elem</code> 开头位置前插入 <code>html</code>，</li> <li><code>&quot;afterbegin&quot;</code> —— 在 <code>elem</code> 开头位置后插入 <code>html</code>（译注：即 <code>elem</code> 元素内部的第一个子节点之前），</li> <li><code>&quot;beforeend&quot;</code> —— 在 <code>elem</code> 结束位置前插入 <code>html</code>（译注：即 <code>elem</code> 元素内部的最后一个子节点之后），</li> <li><code>&quot;afterend&quot;</code> —— 在 <code>elem</code> 结束位置后插入 <code>html</code>。</li></ul> <p>变种：</p> <ul><li><code>elem.insertAdjacentText(where, text)</code> ——作为文本插入</li> <li><code>elem.insertAdjacentElement(where, elem)</code> ——插入元素</li></ul> <h3 id="克隆节点：clonenode"><a href="#克隆节点：clonenode" class="header-anchor">#</a> 克隆节点：cloneNode</h3> <ul><li><code>elem.cloneNode(true)</code> 方法用来对一个元素进行“深”克隆 —— 包括所有特性和子元素。<code>elem.cloneNode(false)</code> 方法只克隆该元素本身，不对子元素进行克隆。</li></ul> <h2 id="样式操作"><a href="#样式操作" class="header-anchor">#</a> 样式操作</h2> <h3 id="两种方式"><a href="#两种方式" class="header-anchor">#</a> 两种方式</h3> <ul><li>内联样式： <code>&lt;div style=&quot;...&quot;&gt;</code></li> <li>引用 CSS 类： <code>&lt;div class=&quot;...&quot;&gt;</code></li></ul> <h3 id="classname-和-classlist"><a href="#classname-和-classlist" class="header-anchor">#</a> className 和 classList</h3> <ul><li><code>classsName</code> ——获取元素的 <code>class</code>  属性，字符串。</li> <li><code>classList</code> ——获取元素的 <code>classList</code>  列表。</li></ul> <p><code>classList</code>  方法：</p> <ul><li><code>elem.classList.add/remove(&quot;class&quot;)</code> —— 添加/移除类。</li> <li><code>elem.classList.toggle(&quot;class&quot;)</code> —— 如果类存在就移除，否则添加。</li> <li><code>elem.classList.contains(&quot;class&quot;)</code> —— 返回 <code>true/false</code>，检查给定类。</li></ul> <h3 id="元素样式"><a href="#元素样式" class="header-anchor">#</a> 元素样式</h3> <p><code>elem.style</code>  属性是一个对象，它对应与 <code>style</code>  特性中所写的内容。访问时需要使用 <code>camelCase</code>  命名法。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>background-color  =&gt; elem.style.backgroundColor
z-index           =&gt; elem.style.zIndex
border-left-width =&gt; elem.style.borderLeftWidth
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>注意： <code>style</code>  属性仅对 <code>style</code>  属性值进行操作，而不是任何 CSS 级联</strong></p> <h3 id="计算样式-getcomputedstyle"><a href="#计算样式-getcomputedstyle" class="header-anchor">#</a> 计算样式: getComputedStyle</h3> <p><code>getComputedStyle(element[, pseudo])</code>  返回与 <code>style</code>  对象类似且包含了所有类的对象，是只读的。</p> <ul><li><code>element</code> ——读取样式值的元素。</li> <li><code>pseudi</code> ——伪元素</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">body</span> <span class="token punctuation">{</span>
      <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
      <span class="token property">margin</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">let</span> computedStyle <span class="token operator">=</span> <span class="token function">getComputedStyle</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 现在我们可以读出页边距和颜色了</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>computedStyle<span class="token punctuation">.</span>marginTop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5px</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>computedStyle<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rgb(255, 0, 0)</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">注意</p> <p>计算值与解析值</p> <ul><li><code>computed</code> 样式值是应用所有 CSS 规则和 CSS 继承之后的值，这是 CSS 级联的结果。它可以是 <code>height:1em</code> 或者 <code>font-size:125%</code>。</li> <li><code>resolved</code> 样式值最终应用于元素值。像 <code>1em</code> 或者 <code>125%</code> 这样的值都是相对的。浏览器会进行值计算，然后对其进行 <code>fixed</code> 和 <code>absolute</code>，例如：<code>height:20px</code> 或 <code>font-size:16px</code>。对于几何属性，解析值可能是一个浮点，如<code>width:50.5px</code>。</li></ul> <p><code>getComputedStyle</code>实际上返回的是属性的解析值。</p></div> <h2 id="元素的尺寸与滚动"><a href="#元素的尺寸与滚动" class="header-anchor">#</a> 元素的尺寸与滚动</h2> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%B0%BA%E5%AF%B8-2019-12-25.png?x-oss-process=style/alin" alt="dom-元素的尺寸-2019-12-25.png"></p> <ul><li><code>offsetLeft</code> / <code>offsetTop</code> ——提供相对于元素左上角的 x/y 坐标。</li> <li><code>offsetWidth</code> / <code>offsetHeight</code> ——它们提供元素的“外部”宽度/高度。换句话说，它的完整大小包括边框。</li> <li><code>clientLeft</code> / <code>clientTop</code> ——内侧与外侧的相对坐标。</li> <li><code>clientWidth</code>  / <code>clientHeight</code> ——提供元素边框内区域的大小。包含内容宽度与内填充宽度，不包含滚动条宽度。</li> <li><code>scrollWidth</code> / <code>scrollHeight</code> ——包含滚动（隐藏部分）</li></ul> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E5%85%83%E7%B4%A0%E7%9A%84%E6%BB%9A%E5%8A%A8-2019-12-25.png?x-oss-process=style/alin" alt="dom-元素的滚动-2019-12-25.png"></p> <ul><li><code>scrollLeft</code> / <code>scrollTop</code> ——可修改。
将 <code>scrollTop</code> 设置为 <code>0</code> 或 <code>Infinity</code> 将使元素分别滚动到顶部/底部。</li></ul> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E5%85%83%E7%B4%A0%E7%9A%84%E6%BB%9A%E5%8A%A82-2019-12-25.png?x-oss-process=style/alin" alt="dom-元素的滚动2-2019-12-25.png"></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>CSS 宽度与 clientWidth 的不同点</p> <ol><li><code>clientWidth</code> 值是数值，然而 <code>getComputedStyle(elem).width</code> 返回一个包含 <code>px</code> 的字符串。</li> <li><code>getComputedStyle</code> 可能返回非数值的结果，例如内联元素的 <code>&quot;auto&quot;</code>。</li> <li><code>clientWidth</code> 是元素的内部内容区域加上内间距，而 CSS 宽度（具有标准的 <code>box-sizing</code>）是内部<strong>不包括内间距</strong>的空间区域。</li> <li>如果有一个滚动条，一般浏览器保留它的空间，有的浏览器从 CSS 宽度中减去这个空间（因为它不再用于内容），而有些则不这样做。<code>clientWidth</code> 属性总是相同的：如果保留了滚动条，那么它的宽度将被删去。</li></ol></div> <h2 id="window-尺寸与滚动"><a href="#window-尺寸与滚动" class="header-anchor">#</a> window 尺寸与滚动</h2> <h3 id="窗口的宽度-高度"><a href="#窗口的宽度-高度" class="header-anchor">#</a> 窗口的宽度/高度</h3> <ol><li><code>documentElement.clientWidth</code> / <code>documentElement.clientHeight</code> —— <code>documentElement</code>  元素的宽高，包含滚动条。</li> <li><code>window.innerWidth / Height</code> ——不包含滚动条的窗口尺寸。</li></ol> <h3 id="文档的宽度-高度"><a href="#文档的宽度-高度" class="header-anchor">#</a> 文档的宽度/高度</h3> <p>要获得可靠的窗口大小，应该采用这些属性的最大值：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> scrollHeight <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Full document height, with scrolled out part: '</span> <span class="token operator">+</span> scrollHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="获取当前滚动状态"><a href="#获取当前滚动状态" class="header-anchor">#</a> 获取当前滚动状态</h3> <ul><li>常规元素： <code>elem.scrollLeft/scrollTop</code></li> <li>文档：使用 <code>document.body</code>  代替有 bugs 的  <code>documentElement.scrollTop/Left</code> ，也可以使用特殊属性 <code>window,pageXOffset/pageYOffset</code></li></ul> <h3 id="滚动到位置"><a href="#滚动到位置" class="header-anchor">#</a> 滚动到位置</h3> <p>注意：尽量不使用修改  <code>documentElement.scrollLeft/Top</code>  和 <code>document.body.scrollLeft/Top</code>  的方法滚动到某一个位置。</p> <p>更加通用的解决方案：使用 <code>window.scrollBy(x, y)</code>  和 <code>window.scrollTo(pageX, pageY)</code></p> <h3 id="滚动到视图"><a href="#滚动到视图" class="header-anchor">#</a> 滚动到视图</h3> <p>调用 <code>elem.scrollIntoView(top)</code> 会使 <code>elem</code> 滚动到可视范围。它有一个结论：</p> <ul><li>如果 <code>top=true</code>（默认值），页面滚动使 <code>elem</code> 会出现到窗口顶部。元素的上边缘与窗口顶部对齐。</li> <li>如果 <code>top=false</code>，则页面滚动使 <code>elem</code> 会出现在窗口底部。元素的下边缘与窗口底部对齐。</li></ul> <h3 id="禁止滚动"><a href="#禁止滚动" class="header-anchor">#</a> 禁止滚动</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>overflow <span class="token operator">=</span> <span class="token string">'hidden'</span><span class="token punctuation">;</span> <span class="token comment">// 禁止滚动</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>overflow <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token comment">// 恢复滚动</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="坐标"><a href="#坐标" class="header-anchor">#</a> 坐标</h2> <p>大多数 JavaScript 方法处理的是以下两种坐标系中的一个：</p> <ol><li>相对于窗口（或者另一个 viewport）顶部/左侧计算的坐标</li> <li>相对于文档顶部/左侧计算的坐标</li></ol> <h3 id="窗口坐标：getboundingclientrect"><a href="#窗口坐标：getboundingclientrect" class="header-anchor">#</a> 窗口坐标：getBoundingClientRect</h3> <p>窗口的坐标是从窗口的左上角开始计算的。<code>elem.getBoundingClientRect()</code> 方法返回一个 <code>elem</code> 的窗口坐标对象，这个对象有以下这些属性：</p> <ul><li><code>top</code> — 元素顶部边缘的 Y 坐标</li> <li><code>left</code> — 元素左边边缘的 X 坐标</li> <li><code>right</code> — 元素右边边缘的 X 坐标</li> <li><code>bottom</code> — 元素底部边缘的 Y 坐标</li></ul> <p><img src="https://allin-bucket.oss-cn-beijing.aliyuncs.com/blog/dom-%E5%85%83%E7%B4%A0%E7%9A%84%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87-2019-12-25.png?x-oss-process=style/alin" alt="dom-元素的窗口坐标-2019-12-25.png"></p> <p><strong>注意：坐标的右/底部和 CSS 中的属性是不同的。</strong></p> <h3 id="elementfrompoint-x-y"><a href="#elementfrompoint-x-y" class="header-anchor">#</a> elementFromPoint(x, y)</h3> <p>调用 <code>document.elementFromPoint(x, y)</code> 方法返回窗口坐标 <code>(x, y)</code> 中最顶层的元素。</p> <p><strong>注意：对于在窗口之外的坐标， <code>elementFromPoint</code>  返回 <code>null</code></strong></p> <h3 id="文档坐标"><a href="#文档坐标" class="header-anchor">#</a> 文档坐标</h3> <ul><li>文档相对坐标是从文档的左上角开始计算，而不是窗口。</li> <li>在 CSS 中，窗口坐标对应的是 <code>position:fixed</code>，而文档坐标则类似顶部的 <code>position:absolute</code>。</li> <li>我们可以使用 <code>position:absolute</code> 和 <code>top/left</code> 来把一些东西放到文档中的固定位置，以便在页面滚动时元素仍能保留在那里。但是我们首先需要正确的坐标。</li> <li>为了清楚起见我们把窗口坐标叫做 <code>(clientX,clientY)</code> 把文档坐标叫做 <code>(pageX,pageY)</code>。</li></ul> <h3 id="获取文档坐标"><a href="#获取文档坐标" class="header-anchor">#</a> 获取文档坐标</h3> <ul><li><code>pageY</code>  = <code>clientY</code> + 文档垂直部分滚动的高度。</li> <li><code>pageX</code>  = <code>clientX</code> + 文档水平部分滚动的宽度。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取元素的文档坐标</span>
<span class="token keyword">function</span> <span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> box <span class="token operator">=</span> elem<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    top<span class="token punctuation">:</span> box<span class="token punctuation">.</span>top <span class="token operator">+</span> pageYOffset<span class="token punctuation">,</span>
    left<span class="token punctuation">:</span> box<span class="token punctuation">.</span>left <span class="token operator">+</span> pageXOffset<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">修订于:</span> <span class="time">2019-12-25 23:50:08</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/advance/web/browser.html">前端与浏览器</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.0d36fc07.js" defer></script><script src="/assets/js/2.b6aa8f81.js" defer></script><script src="/assets/js/10.8bfd4ea1.js" defer></script>
  </body>
</html>
